import streamlit as st
import numpy as np, pandas as pd, datetime as dt
from io import StringIO
from sklearn.linear_model import LogisticRegression
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import make_pipeline
import matplotlib.pyplot as plt

# Optional PDF report (kept very lightweight & offline)
try:
    from fpdf import FPDF
    HAS_FPDF = True
except Exception:
    HAS_FPDF = False

# =========================
# App meta
# =========================
st.set_page_config(page_title="NoiseShield AI", page_icon="üî∞", layout="centered")

# ---------- Session init ----------
if "results" not in st.session_state:
    # per-domain last result
    st.session_state["results"] = {"Soil": None, "Health": None, "Water": None}
if "history" not in st.session_state:
    # last 3 confidence values per domain (for trends)
    st.session_state["history"] = {"Soil": [], "Health": [], "Water": []}
if "last_stable" not in st.session_state:
    # last known safe reading per domain when confidence was decent
    st.session_state["last_stable"] = {"Soil": None, "Health": None, "Water": None}

# =========================
# Theme
# =========================
if "theme_mode" not in st.session_state:
    st.session_state["theme_mode"] = "Dark"

theme_choice = st.sidebar.radio("Theme", ["Light", "Dark"],
                                index=0 if st.session_state["theme_mode"] == "Light" else 1)
st.session_state["theme_mode"] = theme_choice
is_dark = st.session_state["theme_mode"] == "Dark"

bg_color   = "#0E1117" if is_dark else "#FFFFFF"
text_color = "#FAFAFA" if is_dark else "#111111"
accent     = "#00B4B4" if is_dark else "#0A84FF"
banner_fg  = accent
panel_bg   = "#151922" if is_dark else "#F7F9FC"

st.markdown(f"""
<style>
  body, .stApp {{ background-color: {bg_color}; color: {text_color}; }}
  .stButton>button {{ background-color: {accent}; color: white; border-radius: 8px; font-weight: 600; border: 0; }}
  .stProgress > div > div {{ background-color: {accent} !important; }}
  .block-container {{ padding-top: 1.0rem; max-width: 980px; }}
  h2, h3, h4, h5, h6 {{ color: {banner_fg}; }}
  label, .stTextInput label, .stNumberInput label {{
    color: {'#EDEDED' if is_dark else '#1F1F1F'} !important; font-weight: 600;
  }}
  .sdg-badges {{ display:flex; gap:8px; flex-wrap:wrap; justify-content:center; margin:6px 0 0 0; }}
  .sdg-badge {{
    padding:6px 10px; border-radius:8px; font-weight:700; font-size:12px;
    background: {accent}22; color: {banner_fg}; border: 1px solid {banner_fg}44;
  }}
  .panel {{
    background:{panel_bg}; padding:12px 14px; border-radius:10px; border:1px solid {banner_fg}30;
  }}
  * {{ transition: background-color .25s ease, color .25s ease; }}
</style>
""", unsafe_allow_html=True)

# =========================
# Languages (EN, Telugu, Hindi, Tamil, Bengali, Marathi)
# =========================
LANG = {
    "English": {
        "title": "NoiseShield AI ¬∑ Quantum-Inspired Diagnostics",
        "sdg2": "SDG 2 ¬∑ Zero Hunger",
        "sdg3": "SDG 3 ¬∑ Good Health",
        "sdg6": "SDG 6 ¬∑ Clean Water",
        "tabs": ["Soil (SDG 2)", "Health (SDG 3)", "Water (SDG 6)",
                 "Quantum View", "Reports", "SDG Dashboard", "Cross-Domain Stability"],
        "controls": "App Controls",
        "noise": "Simulated Sensor Noise (%)",
        "soil": "Soil Fertility Analysis (Offline)",
        "health": "Health Diagnostics (Offline)",
        "water": "Water Quality (Offline)",
        "quantum": "Quantum-Inspired View",
        "reports": "Local Reports (Offline)",
        "dashboard": "SDG Dashboard Summary",
        "stability": "Cross-Domain Stability (Noise vs Probability)",
        "predicted": "Predicted Result",
        "confidence": "Confidence",
        "baseline": "Baseline prob",
        "var": "Disagreement var",
        "download_soil": "Download Soil Result (CSV)",
        "download_health": "Download Health Result (CSV)",
        "download_water": "Download Water Result (CSV)",
        "download_summary": "Download Summary (CSV)",
        "download_pdf": "Download PDF Report",
        "pdf_missing": "Install 'fpdf' to enable PDF report (pip install fpdf).",
        "why": "Why this result?",
        "last_safe": "Last Known Safe Reading",
        "unstable": "Data unstable ‚Äî showing last safe reading",
        "domain": "Domain",
        "prediction": "Prediction",
        "prob": "Probability",
        "conf": "Confidence",
        "time": "Timestamp",
        "overall": "Overall Sustainability Confidence",
        "excellent": "üü¢ Excellent",
        "moderate": "üü° Moderate",
        "needs": "üî¥ Needs Work",
        "trend": "Confidence Trends (last 3 per domain)",
        "caption": "Quantum-inspired, offline tool for soil, health, and water diagnostics in low-resource settings.",
        "health_label_pos": "Possible Condition",
        "health_label_neg": "Healthy",
        "soil_label_pos": "Nutrient Deficient",
        "soil_label_neg": "Fertile",
        "water_label_pos": "Contaminated",
        "water_label_neg": "Safe",
        "inputs": "Inputs",
        "noise_level": "Noise Level",
        "mode": "Mode",
        "note_panel": "Designed for YCS competition & college admissions: explainable, robust, and offline."
    },
    "‡∞§‡±Ü‡∞≤‡±Å‡∞ó‡±Å": {  # Telugu
        "title": "‡∞®‡∞æ‡∞Ø‡∞ø‡∞∏‡±ç‚Äå‡∞∑‡±Ä‡∞≤‡±ç‡∞°‡±ç AI ¬∑ ‡∞ï‡±ç‡∞µ‡∞æ‡∞Ç‡∞ü‡∞Æ‡±ç ‡∞™‡±ç‡∞∞‡±á‡∞∞‡∞ø‡∞§ ‡∞®‡∞ø‡∞∞‡±ç‡∞ß‡∞æ‡∞∞‡∞£‡∞≤‡±Å",
        "sdg2": "SDG 2 ¬∑ ‡∞Ü‡∞ï‡∞≤‡∞ø ‡∞®‡∞ø‡∞∞‡±ç‡∞Æ‡±Ç‡∞≤‡∞®",
        "sdg3": "SDG 3 ¬∑ ‡∞Ü‡∞∞‡±ã‡∞ó‡±ç‡∞Ø‡∞Æ‡±Å",
        "sdg6": "SDG 6 ¬∑ ‡∞∂‡±Å‡∞≠‡±ç‡∞∞‡∞Æ‡±à‡∞® ‡∞®‡±Ä‡∞∞‡±Å",
        "tabs": ["‡∞Æ‡∞ü‡±ç‡∞ü‡∞ø (SDG 2)", "‡∞Ü‡∞∞‡±ã‡∞ó‡±ç‡∞Ø‡∞Ç (SDG 3)", "‡∞®‡±Ä‡∞∞‡±Å (SDG 6)",
                 "‡∞ï‡±ç‡∞µ‡∞æ‡∞Ç‡∞ü‡∞Æ‡±ç ‡∞µ‡±Ä‡∞Ø‡±Ç", "‡∞∞‡∞ø‡∞™‡±ã‡∞∞‡±ç‡∞ü‡±ç‡∞∏‡±ç", "SDG ‡∞°‡±ç‡∞Ø‡∞æ‡∞∑‡±ç‚Äå‡∞¨‡±ã‡∞∞‡±ç‡∞°‡±ç", "‡∞ï‡±ç‡∞∞‡∞æ‡∞∏‡±ç-‡∞°‡±ä‡∞Æ‡±à‡∞®‡±ç ‡∞∏‡±ç‡∞•‡∞ø‡∞∞‡∞§‡±ç‡∞µ‡∞Ç"],
        "controls": "‡∞Ø‡∞æ‡∞™‡±ç ‡∞ï‡∞Ç‡∞ü‡±ç‡∞∞‡±ã‡∞≤‡±ç‡∞∏‡±ç",
        "noise": "‡∞∏‡±Ü‡∞®‡±ç‡∞∏‡∞æ‡∞∞‡±ç ‡∞∂‡∞¨‡±ç‡∞¶‡∞Ç (%)",
        "soil": "‡∞Æ‡∞ü‡±ç‡∞ü‡∞ø ‡∞∏‡∞æ‡∞∞‡∞µ‡∞Ç‡∞§‡∞§ ‡∞µ‡∞ø‡∞∂‡±ç‡∞≤‡±á‡∞∑‡∞£ (‡∞Ü‡∞´‡±ç‚Äå‡∞≤‡±à‡∞®‡±ç)",
        "health": "‡∞Ü‡∞∞‡±ã‡∞ó‡±ç‡∞Ø ‡∞®‡∞ø‡∞∞‡±ç‡∞ß‡∞æ‡∞∞‡∞£ (‡∞Ü‡∞´‡±ç‚Äå‡∞≤‡±à‡∞®‡±ç)",
        "water": "‡∞®‡±Ä‡∞ü‡∞ø ‡∞®‡∞æ‡∞£‡±ç‡∞Ø‡∞§ (‡∞Ü‡∞´‡±ç‚Äå‡∞≤‡±à‡∞®‡±ç)",
        "quantum": "‡∞ï‡±ç‡∞µ‡∞æ‡∞Ç‡∞ü‡∞Æ‡±ç ‡∞™‡±ç‡∞∞‡±á‡∞∞‡∞£ ‡∞µ‡±Ä‡∞Ø‡±Ç",
        "reports": "‡∞≤‡±ã‡∞ï‡∞≤‡±ç ‡∞∞‡∞ø‡∞™‡±ã‡∞∞‡±ç‡∞ü‡±ç‡∞∏‡±ç (‡∞Ü‡∞´‡±ç‚Äå‡∞≤‡±à‡∞®‡±ç)",
        "dashboard": "SDG ‡∞°‡±ç‡∞Ø‡∞æ‡∞∑‡±ç‚Äå‡∞¨‡±ã‡∞∞‡±ç‡∞°‡±ç ‡∞∏‡∞Æ‡±ç‡∞Æ‡∞∞‡±Ä",
        "stability": "‡∞ï‡±ç‡∞∞‡∞æ‡∞∏‡±ç-‡∞°‡±ä‡∞Æ‡±à‡∞®‡±ç ‡∞∏‡±ç‡∞•‡∞ø‡∞∞‡∞§‡±ç‡∞µ‡∞Ç (‡∞®‡∞æ‡∞Ø‡∞ø‡∞∏‡±ç vs Probability)",
        "predicted": "‡∞Ö‡∞Ç‡∞ö‡∞®‡∞æ ‡∞´‡∞≤‡∞ø‡∞§‡∞Ç",
        "confidence": "‡∞®‡∞Æ‡±ç‡∞Æ‡∞ï‡∞Ç",
        "baseline": "‡∞¨‡±á‡∞∏‡±ç‚Äå‡∞≤‡±à‡∞®‡±ç ‡∞Ö‡∞µ‡∞ï‡∞æ‡∞∂‡∞Ç",
        "var": "‡∞µ‡∞ø‡∞≠‡±á‡∞¶‡∞Ç variance",
        "download_soil": "‡∞Æ‡∞ü‡±ç‡∞ü‡∞ø ‡∞´‡∞≤‡∞ø‡∞§‡∞Ç (CSV)",
        "download_health": "‡∞Ü‡∞∞‡±ã‡∞ó‡±ç‡∞Ø ‡∞´‡∞≤‡∞ø‡∞§‡∞Ç (CSV)",
        "download_water": "‡∞®‡±Ä‡∞ü‡∞ø ‡∞´‡∞≤‡∞ø‡∞§‡∞Ç (CSV)",
        "download_summary": "‡∞∏‡∞Æ‡±ç‡∞Æ‡∞∞‡±Ä (CSV)",
        "download_pdf": "PDF ‡∞∞‡∞ø‡∞™‡±ã‡∞∞‡±ç‡∞ü‡±ç",
        "pdf_missing": "'fpdf' ‡∞á‡∞®‡±ç‚Äå‡∞∏‡±ç‡∞ü‡∞æ‡∞≤‡±ç ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø (pip install fpdf).",
        "why": "‡∞à ‡∞´‡∞≤‡∞ø‡∞§‡∞æ‡∞®‡∞ø‡∞ï‡∞ø ‡∞ï‡∞æ‡∞∞‡∞£‡∞Ç?",
        "last_safe": "‡∞ó‡∞§ ‡∞∏‡±Å‡∞∞‡∞ï‡±ç‡∞∑‡∞ø‡∞§ ‡∞∞‡±Ä‡∞°‡∞ø‡∞Ç‡∞ó‡±ç",
        "unstable": "‡∞°‡±á‡∞ü‡∞æ ‡∞∏‡±ç‡∞•‡∞ø‡∞∞‡∞Ç‡∞ó‡∞æ ‡∞≤‡±á‡∞¶‡±Å ‚Äî ‡∞ö‡∞ø‡∞µ‡∞∞‡∞ø ‡∞∏‡±Å‡∞∞‡∞ï‡±ç‡∞∑‡∞ø‡∞§ ‡∞∞‡±Ä‡∞°‡∞ø‡∞Ç‡∞ó‡±ç ‡∞ö‡±Ç‡∞™‡∞ø‡∞Ç‡∞™‡±Å",
        "domain": "‡∞°‡±ä‡∞Æ‡±à‡∞®‡±ç",
        "prediction": "‡∞´‡∞≤‡∞ø‡∞§‡∞Ç",
        "prob": "‡∞∏‡∞Ç‡∞≠‡∞æ‡∞µ‡±ç‡∞Ø‡∞§",
        "conf": "‡∞®‡∞Æ‡±ç‡∞Æ‡∞ï‡∞Ç",
        "time": "‡∞∏‡∞Æ‡∞Ø‡∞Ç",
        "overall": "‡∞∏‡∞Æ‡∞ó‡±ç‡∞∞ ‡∞∏‡±Å‡∞∏‡±ç‡∞•‡∞ø‡∞∞‡∞§ ‡∞®‡∞Æ‡±ç‡∞Æ‡∞ï‡∞Ç",
        "excellent": "üü¢ ‡∞Ö‡∞¶‡±ç‡∞≠‡±Å‡∞§‡∞Ç",
        "moderate": "üü° ‡∞∏‡∞∞‡∞æ‡∞∏‡∞∞‡∞ø",
        "needs": "üî¥ ‡∞Æ‡±Ü‡∞∞‡±Å‡∞ó‡±Å‡∞≤‡±Å ‡∞Ö‡∞µ‡∞∏‡∞∞‡∞Ç",
        "trend": "‡∞®‡∞Æ‡±ç‡∞Æ‡∞ï‡∞Ç ‡∞ü‡±ç‡∞∞‡±Ü‡∞Ç‡∞°‡±ç‡∞∏‡±ç (‡∞ö‡∞ø‡∞µ‡∞∞‡∞ø 3)",
        "caption": "‡∞ï‡±ç‡∞µ‡∞æ‡∞Ç‡∞ü‡∞Æ‡±ç ‡∞™‡±ç‡∞∞‡±á‡∞∞‡∞£‡∞§‡±ã, ‡∞Ü‡∞´‡±ç‚Äå‡∞≤‡±à‡∞®‡±ç ‡∞ü‡±Ç‡∞≤‡±ç ‚Äî ‡∞§‡∞ï‡±ç‡∞ï‡±Å‡∞µ ‡∞µ‡∞®‡∞∞‡±Å‡∞≤ ‡∞™‡±ç‡∞∞‡∞æ‡∞Ç‡∞§‡∞æ‡∞≤‡∞ï‡±Å.",
        "health_label_pos": "‡∞∏‡∞æ‡∞ß‡±ç‡∞Ø‡∞Æ‡±à‡∞® ‡∞™‡∞∞‡∞ø‡∞∏‡±ç‡∞•‡∞ø‡∞§‡∞ø",
        "health_label_neg": "‡∞Ü‡∞∞‡±ã‡∞ó‡±ç‡∞Ø‡∞Ç‡∞ó‡∞æ ‡∞â‡∞Ç‡∞¶‡∞ø",
        "soil_label_pos": "‡∞™‡±ã‡∞∑‡∞ï ‡∞≤‡±ã‡∞™‡∞Ç",
        "soil_label_neg": "‡∞∏‡∞æ‡∞∞‡∞µ‡∞Ç‡∞§‡∞Æ‡±à‡∞®‡∞¶‡∞ø",
        "water_label_pos": "‡∞ï‡∞æ‡∞≤‡±Å‡∞∑‡±ç‡∞Ø‡∞Ç",
        "water_label_neg": "‡∞∏‡±Å‡∞∞‡∞ï‡±ç‡∞∑‡∞ø‡∞§‡∞Ç",
        "inputs": "‡∞á‡∞®‡±ç‡∞™‡±Å‡∞ü‡±ç‡∞∏‡±ç",
        "noise_level": "‡∞®‡∞æ‡∞Ø‡∞ø‡∞∏‡±ç ‡∞∏‡±ç‡∞•‡∞æ‡∞Ø‡∞ø",
        "mode": "‡∞Æ‡±ã‡∞°‡±ç",
        "note_panel": "YCS & ‡∞ï‡∞æ‡∞≤‡±á‡∞ú‡±ç ‡∞Ö‡∞°‡±ç‡∞Æ‡∞ø‡∞∑‡∞®‡±ç‡∞∏‡±ç ‡∞ï‡±ã‡∞∏‡∞Ç ‡∞∞‡±Ç‡∞™‡±ä‡∞Ç‡∞¶‡∞ø‡∞Ç‡∞ö‡∞¨‡∞°‡∞ø‡∞Ç‡∞¶‡∞ø: explainable, robust, offline."
    },
    "‡§π‡§ø‡§Ç‡§¶‡•Ä": {  # Hindi
        "title": "NoiseShield AI ¬∑ ‡§ï‡•ç‡§µ‡§æ‡§Ç‡§ü‡§Æ-‡§™‡•ç‡§∞‡•á‡§∞‡§ø‡§§ ‡§®‡§ø‡§¶‡§æ‡§®",
        "sdg2": "SDG 2 ¬∑ ‡§≠‡•Å‡§ñ‡§Æ‡§∞‡•Ä ‡§Æ‡•Å‡§ï‡•ç‡§§",
        "sdg3": "SDG 3 ¬∑ ‡§â‡§§‡•ç‡§§‡§Æ ‡§∏‡•ç‡§µ‡§æ‡§∏‡•ç‡§•‡•ç‡§Ø",
        "sdg6": "SDG 6 ¬∑ ‡§∏‡•ç‡§µ‡§ö‡•ç‡§õ ‡§™‡§æ‡§®‡•Ä",
        "tabs": ["‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä (SDG 2)", "‡§∏‡•ç‡§µ‡§æ‡§∏‡•ç‡§•‡•ç‡§Ø (SDG 3)", "‡§ú‡§≤ (SDG 6)",
                 "‡§ï‡•ç‡§µ‡§æ‡§Ç‡§ü‡§Æ ‡§¶‡•É‡§∂‡•ç‡§Ø", "‡§∞‡§ø‡§™‡•ã‡§∞‡•ç‡§ü‡•ç‡§∏", "SDG ‡§°‡•à‡§∂‡§¨‡•ã‡§∞‡•ç‡§°", "‡§ï‡•ç‡§∞‡•â‡§∏-‡§°‡•ã‡§Æ‡•á‡§® ‡§∏‡•ç‡§•‡§ø‡§∞‡§§‡§æ"],
        "controls": "‡§è‡§™ ‡§ï‡§Ç‡§ü‡•ç‡§∞‡•ã‡§≤‡•ç‡§∏",
        "noise": "‡§∏‡•á‡§Ç‡§∏‡§∞ ‡§∂‡•ã‡§∞ (%)",
        "soil": "‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§â‡§∞‡•ç‡§µ‡§∞‡§§‡§æ ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£ (‡§ë‡§´‡§≤‡§æ‡§á‡§®)",
        "health": "‡§∏‡•ç‡§µ‡§æ‡§∏‡•ç‡§•‡•ç‡§Ø ‡§®‡§ø‡§¶‡§æ‡§® (‡§ë‡§´‡§≤‡§æ‡§á‡§®)",
        "water": "‡§ú‡§≤ ‡§ó‡•Å‡§£‡§µ‡§§‡•ç‡§§‡§æ (‡§ë‡§´‡§≤‡§æ‡§á‡§®)",
        "quantum": "‡§ï‡•ç‡§µ‡§æ‡§Ç‡§ü‡§Æ-‡§™‡•ç‡§∞‡•á‡§∞‡§ø‡§§ ‡§¶‡•É‡§∂‡•ç‡§Ø",
        "reports": "‡§∏‡•ç‡§•‡§æ‡§®‡•Ä‡§Ø ‡§∞‡§ø‡§™‡•ã‡§∞‡•ç‡§ü‡•ç‡§∏ (‡§ë‡§´‡§≤‡§æ‡§á‡§®)",
        "dashboard": "SDG ‡§°‡•à‡§∂‡§¨‡•ã‡§∞‡•ç‡§° ‡§∏‡§æ‡§∞",
        "stability": "‡§ï‡•ç‡§∞‡•â‡§∏-‡§°‡•ã‡§Æ‡•á‡§® ‡§∏‡•ç‡§•‡§ø‡§∞‡§§‡§æ (Noise vs Probability)",
        "predicted": "‡§Ö‡§®‡•Å‡§Æ‡§æ‡§®‡§ø‡§§ ‡§™‡§∞‡§ø‡§£‡§æ‡§Æ",
        "confidence": "‡§µ‡§ø‡§∂‡•ç‡§µ‡§æ‡§∏",
        "baseline": "‡§¨‡•á‡§∏‡§≤‡§æ‡§á‡§® ‡§™‡•ç‡§∞‡§æ‡§Ø‡§ø‡§ï‡§§‡§æ",
        "var": "‡§Ö‡§∏‡§π‡§Æ‡§§‡§ø variance",
        "download_soil": "‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§™‡§∞‡§ø‡§£‡§æ‡§Æ (CSV)",
        "download_health": "‡§∏‡•ç‡§µ‡§æ‡§∏‡•ç‡§•‡•ç‡§Ø ‡§™‡§∞‡§ø‡§£‡§æ‡§Æ (CSV)",
        "download_water": "‡§ú‡§≤ ‡§™‡§∞‡§ø‡§£‡§æ‡§Æ (CSV)",
        "download_summary": "‡§∏‡§æ‡§∞ (CSV)",
        "download_pdf": "PDF ‡§∞‡§ø‡§™‡•ã‡§∞‡•ç‡§ü",
        "pdf_missing": "'fpdf' ‡§á‡§Ç‡§∏‡•ç‡§ü‡•â‡§≤ ‡§ï‡§∞‡•á‡§Ç (pip install fpdf).",
        "why": "‡§Ø‡§π ‡§™‡§∞‡§ø‡§£‡§æ‡§Æ ‡§ï‡•ç‡§Ø‡•ã‡§Ç?",
        "last_safe": "‡§Ö‡§Ç‡§§‡§ø‡§Æ ‡§∏‡•Å‡§∞‡§ï‡•ç‡§∑‡§ø‡§§ ‡§∞‡•Ä‡§°‡§ø‡§Ç‡§ó",
        "unstable": "‡§°‡•á‡§ü‡§æ ‡§Ö‡§∏‡•ç‡§•‡§ø‡§∞ ‚Äî ‡§Ö‡§Ç‡§§‡§ø‡§Æ ‡§∏‡•Å‡§∞‡§ï‡•ç‡§∑‡§ø‡§§ ‡§∞‡•Ä‡§°‡§ø‡§Ç‡§ó ‡§¶‡§ø‡§ñ‡§æ ‡§∞‡§π‡•á ‡§π‡•à‡§Ç",
        "domain": "‡§°‡•ã‡§Æ‡•á‡§®",
        "prediction": "‡§™‡§∞‡§ø‡§£‡§æ‡§Æ",
        "prob": "‡§™‡•ç‡§∞‡§æ‡§Ø‡§ø‡§ï‡§§‡§æ",
        "conf": "‡§µ‡§ø‡§∂‡•ç‡§µ‡§æ‡§∏",
        "time": "‡§∏‡§Æ‡§Ø",
        "overall": "‡§∏‡§Æ‡§ó‡•ç‡§∞ ‡§∏‡•ç‡§•‡§ø‡§∞‡§§‡§æ ‡§µ‡§ø‡§∂‡•ç‡§µ‡§æ‡§∏",
        "excellent": "üü¢ ‡§â‡§§‡•ç‡§ï‡•É‡§∑‡•ç‡§ü",
        "moderate": "üü° ‡§Æ‡§ß‡•ç‡§Ø‡§Æ",
        "needs": "üî¥ ‡§∏‡•Å‡§ß‡§æ‡§∞ ‡§Ü‡§µ‡§∂‡•ç‡§Ø‡§ï",
        "trend": "‡§µ‡§ø‡§∂‡•ç‡§µ‡§æ‡§∏ ‡§ü‡•ç‡§∞‡•á‡§Ç‡§° (‡§™‡§ø‡§õ‡§≤‡•á 3)",
        "caption": "‡§ï‡•ç‡§µ‡§æ‡§Ç‡§ü‡§Æ-‡§™‡•ç‡§∞‡•á‡§∞‡§ø‡§§, ‡§ë‡§´‡§≤‡§æ‡§á‡§® ‡§ü‡•Ç‡§≤ ‚Äî ‡§ï‡§Æ ‡§∏‡§Ç‡§∏‡§æ‡§ß‡§® ‡§∏‡•á‡§ü‡§ø‡§Ç‡§ó‡•ç‡§∏ ‡§ï‡•á ‡§≤‡§ø‡§è‡•§",
        "health_label_pos": "‡§∏‡§Ç‡§≠‡§æ‡§µ‡§ø‡§§ ‡§∏‡•ç‡§•‡§ø‡§§‡§ø",
        "health_label_neg": "‡§∏‡•ç‡§µ‡§∏‡•ç‡§•",
        "soil_label_pos": "‡§™‡•ã‡§∑‡§ï ‡§ï‡§Æ‡•Ä",
        "soil_label_neg": "‡§â‡§∞‡•ç‡§µ‡§∞",
        "water_label_pos": "‡§¶‡•Ç‡§∑‡§ø‡§§",
        "water_label_neg": "‡§∏‡•Å‡§∞‡§ï‡•ç‡§∑‡§ø‡§§",
        "inputs": "‡§á‡§®‡§™‡•Å‡§ü‡•ç‡§∏",
        "noise_level": "‡§∂‡•ã‡§∞ ‡§∏‡•ç‡§§‡§∞",
        "mode": "‡§Æ‡•ã‡§°",
        "note_panel": "YCS ‡§î‡§∞ ‡§ï‡•â‡§≤‡•á‡§ú ‡§è‡§°‡§Æ‡§ø‡§∂‡§® ‡§π‡•á‡§§‡•Å: explainable, robust, offline."
    },
    "‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç": {  # Tamil
        "title": "NoiseShield AI ¬∑ ‡Æï‡ØÅ‡Æµ‡Ææ‡Æ£‡Øç‡Æü‡ÆÆ‡Øç ‡Æä‡Æï‡Øç‡Æï‡ÆÆ‡ØÇ‡Æü‡Øç‡Æü‡Æø‡ÆØ ‡Æ®‡Ææ‡Æü‡ØÅ‡Æï‡Ææ‡Æ£‡Æ≤‡Øç",
        "sdg2": "SDG 2 ¬∑ ‡Æ™‡Æö‡Æø ‡Æí‡Æ¥‡Æø‡Æ™‡Øç‡Æ™‡ØÅ",
        "sdg3": "SDG 3 ¬∑ ‡Æ®‡Æ≤‡Øç‡Æ≤ ‡ÆÜ‡Æ∞‡Øã‡Æï‡Øç‡Æï‡Æø‡ÆØ‡ÆÆ‡Øç",
        "sdg6": "SDG 6 ¬∑ ‡Æ§‡ØÇ‡ÆØ‡Øç‡ÆÆ‡Øà‡ÆØ‡Ææ‡Æ© ‡Æ®‡ØÄ‡Æ∞‡Øç",
        "tabs": ["‡ÆÆ‡Æ£‡Øç (SDG 2)", "‡ÆÜ‡Æ∞‡Øã‡Æï‡Øç‡Æï‡Æø‡ÆØ‡ÆÆ‡Øç (SDG 3)", "‡Æ®‡ØÄ‡Æ∞‡Øç (SDG 6)",
                 "‡Æï‡ØÅ‡Æµ‡Ææ‡Æ£‡Øç‡Æü‡ÆÆ‡Øç ‡Æï‡Ææ‡Æü‡Øç‡Æö‡Æø", "‡ÆÖ‡Æ±‡Æø‡Æï‡Øç‡Æï‡Øà‡Æï‡Æ≥‡Øç", "SDG ‡Æü‡Ææ‡Æ∑‡Øç‡Æ™‡Øã‡Æ∞‡Øç‡Æü‡ØÅ", "‡Æï‡ØÅ‡Æ±‡ØÅ‡Æï‡Øç‡Æï‡ØÅ-‡Æµ‡Æø‡Æ≥‡Øà‡Æ®‡Æø‡Æ≤‡Øà ‡Æ®‡Æø‡Æ≤‡Øà‡Æ§‡Øç‡Æ§‡Æ©‡Øç‡ÆÆ‡Øà"],
        "controls": "‡ÆÖ‡Æ™‡Øç ‡Æï‡Æü‡Øç‡Æü‡ØÅ‡Æ™‡Øç‡Æ™‡Ææ‡Æü‡ØÅ‡Æï‡Æ≥‡Øç",
        "noise": "‡Æö‡ØÜ‡Æ©‡Øç‡Æö‡Ææ‡Æ∞‡Øç ‡Æö‡Æ§‡Øç‡Æ§‡ÆÆ‡Øç (%)",
        "soil": "‡ÆÆ‡Æ£‡Øç ‡Æµ‡Æ≥‡ÆÆ‡Øç ‡Æ™‡Æï‡ØÅ‡Æ™‡Øç‡Æ™‡Ææ‡ÆØ‡Øç‡Æµ‡ØÅ (‡ÆÜ‡ÆÉ‡Æ™‡Øç‡Æ≤‡Øà‡Æ©‡Øç)",
        "health": "‡Æ®‡Øã‡ÆØ‡Øç ‡Æï‡Æ£‡Øç‡Æü‡Æ±‡Æø‡Æ§‡Æ≤‡Øç (‡ÆÜ‡ÆÉ‡Æ™‡Øç‡Æ≤‡Øà‡Æ©‡Øç)",
        "water": "‡Æ®‡ØÄ‡Æ∞‡Øç ‡Æ§‡Æ∞‡ÆÆ‡Øç (‡ÆÜ‡ÆÉ‡Æ™‡Øç‡Æ≤‡Øà‡Æ©‡Øç)",
        "quantum": "‡Æï‡ØÅ‡Æµ‡Ææ‡Æ£‡Øç‡Æü‡ÆÆ‡Øç-‡Æä‡Æï‡Øç‡Æï ‡Æï‡Ææ‡Æü‡Øç‡Æö‡Æø",
        "reports": "‡Æâ‡Æ≥‡Øç‡Æ≥‡ØÇ‡Æ∞‡Øç ‡ÆÖ‡Æ±‡Æø‡Æï‡Øç‡Æï‡Øà‡Æï‡Æ≥‡Øç (‡ÆÜ‡ÆÉ‡Æ™‡Øç‡Æ≤‡Øà‡Æ©‡Øç)",
        "dashboard": "SDG ‡Æü‡Ææ‡Æ∑‡Øç‡Æ™‡Øã‡Æ∞‡Øç‡Æü‡ØÅ ‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç",
        "stability": "‡Æï‡ØÅ‡Æ±‡ØÅ‡Æï‡Øç‡Æï‡ØÅ-‡Æµ‡Æø‡Æ≥‡Øà‡Æ®‡Æø‡Æ≤‡Øà ‡Æ®‡Æø‡Æ≤‡Øà‡Æ§‡Øç‡Æ§‡Æ©‡Øç‡ÆÆ‡Øà (‡Æö‡Æ§‡Øç‡Æ§‡ÆÆ‡Øç vs Probability)",
        "predicted": "‡ÆÆ‡ØÅ‡Æü‡Æø‡Æµ‡ØÅ",
        "confidence": "‡Æ®‡ÆÆ‡Øç‡Æ™‡Æø‡Æï‡Øç‡Æï‡Øà",
        "baseline": "‡ÆÖ‡Æü‡Æø‡Æ™‡Øç‡Æ™‡Æü‡Øà ‡Æö‡Ææ‡Æ§‡Øç‡Æ§‡Æø‡ÆØ‡ÆÆ‡Øç",
        "var": "‡Æµ‡Øá‡Æ±‡ØÅ‡Æ™‡Ææ‡Æü‡ØÅ variance",
        "download_soil": "‡ÆÆ‡Æ£‡Øç ‡ÆÆ‡ØÅ‡Æü‡Æø‡Æµ‡ØÅ (CSV)",
        "download_health": "‡ÆÜ‡Æ∞‡Øã‡Æï‡Øç‡Æï‡Æø‡ÆØ ‡ÆÆ‡ØÅ‡Æü‡Æø‡Æµ‡ØÅ (CSV)",
        "download_water": "‡Æ®‡ØÄ‡Æ∞‡Øç ‡ÆÆ‡ØÅ‡Æü‡Æø‡Æµ‡ØÅ (CSV)",
        "download_summary": "‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç (CSV)",
        "download_pdf": "PDF ‡ÆÖ‡Æ±‡Æø‡Æï‡Øç‡Æï‡Øà",
        "pdf_missing": "'fpdf' ‡Æ®‡Æø‡Æ±‡ØÅ‡Æµ‡Æµ‡ØÅ‡ÆÆ‡Øç (pip install fpdf).",
        "why": "‡Æè‡Æ©‡Øç ‡Æá‡Æ®‡Øç‡Æ§ ‡ÆÆ‡ØÅ‡Æü‡Æø‡Æµ‡ØÅ?",
        "last_safe": "‡Æï‡Æü‡Øà‡Æö‡Æø ‡Æ™‡Ææ‡Æ§‡ØÅ‡Æï‡Ææ‡Æ™‡Øç‡Æ™‡Ææ‡Æ© ‡Æ∞‡ØÄ‡Æü‡Æø‡Æô‡Øç",
        "unstable": "‡Æ§‡Æ∞‡Æµ‡ØÅ ‡Æ®‡Æø‡Æ≤‡Øà‡Æï‡ØÅ‡Æ≤‡Øà‡Æµ‡ØÅ ‚Äî ‡Æï‡Æü‡Øà‡Æö‡Æø‡Æ™‡Øç ‡Æ™‡Ææ‡Æ§‡ØÅ‡Æï‡Ææ‡Æ™‡Øç‡Æ™‡Ææ‡Æ© ‡Æ∞‡ØÄ‡Æü‡Æø‡Æô‡Øç ‡Æï‡Ææ‡Æü‡Øç‡Æü‡Æ™‡Øç‡Æ™‡Æü‡ØÅ‡Æï‡Æø‡Æ±‡Æ§‡ØÅ",
        "domain": "‡Æ§‡ØÅ‡Æ±‡Øà",
        "prediction": "‡ÆÆ‡ØÅ‡Æü‡Æø‡Æµ‡ØÅ",
        "prob": "‡Æö‡Ææ‡Æ§‡Øç‡Æ§‡Æø‡ÆØ‡ÆÆ‡Øç",
        "conf": "‡Æ®‡ÆÆ‡Øç‡Æ™‡Æø‡Æï‡Øç‡Æï‡Øà",
        "time": "‡Æ®‡Øá‡Æ∞‡ÆÆ‡Øç",
        "overall": "‡ÆÆ‡Øä‡Æ§‡Øç‡Æ§ ‡Æ®‡Æø‡Æ≤‡Øà‡Æ§‡Øç‡Æ§‡Æ©‡Øç‡ÆÆ‡Øà ‡Æ®‡ÆÆ‡Øç‡Æ™‡Æø‡Æï‡Øç‡Æï‡Øà",
        "excellent": "üü¢ ‡Æö‡Æø‡Æ±‡Æ™‡Øç‡Æ™‡ØÅ",
        "moderate": "üü° ‡Æ®‡Æü‡ØÅ‡Æ§‡Øç‡Æ§‡Æ∞‡ÆÆ‡Øç",
        "needs": "üî¥ ‡ÆÆ‡Øá‡ÆÆ‡Øç‡Æ™‡Ææ‡Æü‡ØÅ ‡Æ§‡Øá‡Æµ‡Øà",
        "trend": "‡Æ®‡ÆÆ‡Øç‡Æ™‡Æø‡Æï‡Øç‡Æï‡Øà ‡Æ™‡Øã‡Æï‡Øç‡Æï‡ØÅ (‡Æï‡Æü‡Øà‡Æö‡Æø 3)",
        "caption": "‡Æï‡ØÅ‡Æµ‡Ææ‡Æ£‡Øç‡Æü‡ÆÆ‡Øç ‡Æä‡Æï‡Øç‡Æï‡ÆÆ‡ØÇ‡Æü‡Øç‡Æü‡Æø‡ÆØ, ‡ÆÜ‡ÆÉ‡Æ™‡Øç‡Æ≤‡Øà‡Æ©‡Øç ‡Æï‡Æ∞‡ØÅ‡Æµ‡Æø ‚Äî ‡Æï‡ØÅ‡Æ±‡Øà‡Æ®‡Øç‡Æ§ ‡Æµ‡Æ≥ ‡Æ™‡Æï‡ØÅ‡Æ§‡Æø‡Æï‡Æ≥‡ØÅ‡Æï‡Øç‡Æï‡ØÅ.",
        "health_label_pos": "‡Æö‡Ææ‡Æ§‡Øç‡Æ§‡Æø‡ÆØ‡ÆÆ‡Ææ‡Æ© ‡Æ®‡Æø‡Æ≤‡Øà",
        "health_label_neg": "‡ÆÜ‡Æ∞‡Øã‡Æï‡Øç‡Æï‡Æø‡ÆØ‡ÆÆ‡Øç",
        "soil_label_pos": "‡Æä‡Æü‡Øç‡Æü‡Æö‡Øç‡Æö‡Æ§‡Øç‡Æ§‡ØÅ ‡Æ™‡Æ±‡Øç‡Æ±‡Ææ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Øà",
        "soil_label_neg": "‡Æµ‡Æ≥‡ÆÆ‡Ææ‡Æ©‡Æ§‡ØÅ",
        "water_label_pos": "‡Æï‡Æ¥‡Æø‡Æµ‡ØÅ",
        "water_label_neg": "‡Æ™‡Ææ‡Æ§‡ØÅ‡Æï‡Ææ‡Æ™‡Øç‡Æ™‡Ææ‡Æ©‡Æ§‡ØÅ",
        "inputs": "‡Æâ‡Æ≥‡Øç‡Æ≥‡ØÄ‡Æü‡ØÅ‡Æï‡Æ≥‡Øç",
        "noise_level": "‡Æö‡Æ§‡Øç‡Æ§‡ÆÆ‡Øç",
        "mode": "‡ÆÆ‡ØÅ‡Æ±‡Øà",
        "note_panel": "YCS & ‡Æï‡Æ≤‡Øç‡Æ≤‡ØÇ‡Æ∞‡Æø ‡Æö‡Øá‡Æ∞‡Øç‡Æï‡Øç‡Æï‡Øà ‡Æ®‡Øã‡Æï‡Øç‡Æï‡Æø: explainable, robust, offline."
    },
    "‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ": {  # Bengali
        "title": "NoiseShield AI ¬∑ ‡¶ï‡ßã‡¶Ø‡¶º‡¶æ‡¶®‡ßç‡¶ü‡¶æ‡¶Æ-‡¶™‡ßç‡¶∞‡¶æ‡¶£‡¶ø‡¶§ ‡¶°‡¶æ‡¶Ø‡¶º‡¶æ‡¶ó‡¶®‡¶∏‡ßç‡¶ü‡¶ø‡¶ï",
        "sdg2": "SDG 2 ¬∑ ‡¶ï‡ßç‡¶∑‡ßÅ‡¶ß‡¶æ‡¶Æ‡ßÅ‡¶ï‡ßç‡¶§",
        "sdg3": "SDG 3 ¬∑ ‡¶∏‡ßÅ‡¶∏‡ßç‡¶¨‡¶æ‡¶∏‡ßç‡¶•‡ßç‡¶Ø",
        "sdg6": "SDG 6 ¬∑ ‡¶¨‡¶ø‡¶∂‡ßÅ‡¶¶‡ßç‡¶ß ‡¶™‡¶æ‡¶®‡¶ø",
        "tabs": ["‡¶Æ‡¶æ‡¶ü‡¶ø (SDG 2)", "‡¶∏‡ßç‡¶¨‡¶æ‡¶∏‡ßç‡¶•‡ßç‡¶Ø (SDG 3)", "‡¶™‡¶æ‡¶®‡ßÄ‡¶Ø‡¶º ‡¶ú‡¶≤ (SDG 6)",
                 "‡¶ï‡ßã‡¶Ø‡¶º‡¶æ‡¶®‡ßç‡¶ü‡¶æ‡¶Æ ‡¶≠‡¶ø‡¶â", "‡¶∞‡¶ø‡¶™‡ßã‡¶∞‡ßç‡¶ü", "SDG ‡¶°‡ßç‡¶Ø‡¶æ‡¶∂‡¶¨‡ßã‡¶∞‡ßç‡¶°", "‡¶ï‡ßç‡¶∞‡¶∏-‡¶°‡ßã‡¶Æ‡ßá‡¶á‡¶® ‡¶∏‡ßç‡¶•‡¶æ‡¶Ø‡¶º‡¶ø‡¶§‡ßç‡¶¨"],
        "controls": "‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™ ‡¶ï‡¶®‡ßç‡¶ü‡ßç‡¶∞‡ßã‡¶≤",
        "noise": "‡¶∏‡ßá‡¶®‡ßç‡¶∏‡¶∞ ‡¶®‡¶Ø‡¶º‡ßá‡¶ú (%)",
        "soil": "‡¶Æ‡¶æ‡¶ü‡¶ø‡¶∞ ‡¶â‡¶∞‡ßç‡¶¨‡¶∞‡¶§‡¶æ ‡¶¨‡¶ø‡¶∂‡ßç‡¶≤‡ßá‡¶∑‡¶£ (‡¶Ö‡¶´‡¶≤‡¶æ‡¶á‡¶®)",
        "health": "‡¶∏‡ßç‡¶¨‡¶æ‡¶∏‡ßç‡¶•‡ßç‡¶Ø ‡¶®‡¶ø‡¶∞‡ßç‡¶£‡¶Ø‡¶º (‡¶Ö‡¶´‡¶≤‡¶æ‡¶á‡¶®)",
        "water": "‡¶ú‡¶≤‡ßá‡¶∞ ‡¶ó‡ßÅ‡¶£‡¶Æ‡¶æ‡¶® (‡¶Ö‡¶´‡¶≤‡¶æ‡¶á‡¶®)",
        "quantum": "‡¶ï‡ßã‡¶Ø‡¶º‡¶æ‡¶®‡ßç‡¶ü‡¶æ‡¶Æ-‡¶™‡ßç‡¶∞‡¶æ‡¶£‡¶ø‡¶§ ‡¶≠‡¶ø‡¶â",
        "reports": "‡¶≤‡ßã‡¶ï‡¶æ‡¶≤ ‡¶∞‡¶ø‡¶™‡ßã‡¶∞‡ßç‡¶ü (‡¶Ö‡¶´‡¶≤‡¶æ‡¶á‡¶®)",
        "dashboard": "SDG ‡¶°‡ßç‡¶Ø‡¶æ‡¶∂‡¶¨‡ßã‡¶∞‡ßç‡¶° ‡¶∏‡¶æ‡¶∞‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡ßá‡¶™",
        "stability": "‡¶ï‡ßç‡¶∞‡¶∏-‡¶°‡ßã‡¶Æ‡ßá‡¶á‡¶® ‡¶∏‡ßç‡¶•‡¶æ‡¶Ø‡¶º‡¶ø‡¶§‡ßç‡¶¨ (Noise vs Probability)",
        "predicted": "‡¶Ö‡¶®‡ßÅ‡¶Æ‡ßá‡¶Ø‡¶º ‡¶´‡¶≤‡¶æ‡¶´‡¶≤",
        "confidence": "‡¶Ü‡¶∏‡ßç‡¶•‡¶æ",
        "baseline": "‡¶¨‡ßá‡¶∏‡¶≤‡¶æ‡¶á‡¶® ‡¶∏‡¶Æ‡ßç‡¶≠‡¶æ‡¶¨‡ßç‡¶Ø‡¶§‡¶æ",
        "var": "‡¶¨‡¶ø‡¶≠‡ßá‡¶¶ variance",
        "download_soil": "‡¶Æ‡¶æ‡¶ü‡¶ø ‡¶´‡¶≤‡¶æ‡¶´‡¶≤ (CSV)",
        "download_health": "‡¶∏‡ßç‡¶¨‡¶æ‡¶∏‡ßç‡¶•‡ßç‡¶Ø ‡¶´‡¶≤‡¶æ‡¶´‡¶≤ (CSV)",
        "download_water": "‡¶ú‡¶≤ ‡¶´‡¶≤‡¶æ‡¶´‡¶≤ (CSV)",
        "download_summary": "‡¶∏‡¶æ‡¶∞‡¶æ‡¶Ç‡¶∂ (CSV)",
        "download_pdf": "PDF ‡¶∞‡¶ø‡¶™‡ßã‡¶∞‡ßç‡¶ü",
        "pdf_missing": "'fpdf' ‡¶á‡¶®‡¶∏‡ßç‡¶ü‡¶≤ ‡¶ï‡¶∞‡ßÅ‡¶® (pip install fpdf).",
        "why": "‡¶è‡¶á ‡¶´‡¶≤‡¶æ‡¶´‡¶≤ ‡¶ï‡ßá‡¶®?",
        "last_safe": "‡¶∏‡¶∞‡ßç‡¶¨‡¶∂‡ßá‡¶∑ ‡¶®‡¶ø‡¶∞‡¶æ‡¶™‡¶¶ ‡¶∞‡¶ø‡¶°‡¶ø‡¶Ç",
        "unstable": "‡¶°‡ßá‡¶ü‡¶æ ‡¶Ö‡¶∏‡ßç‡¶•‡¶ø‡¶∞ ‚Äî ‡¶∏‡¶∞‡ßç‡¶¨‡¶∂‡ßá‡¶∑ ‡¶®‡¶ø‡¶∞‡¶æ‡¶™‡¶¶ ‡¶∞‡¶ø‡¶°‡¶ø‡¶Ç ‡¶¶‡ßá‡¶ñ‡¶æ‡¶®‡ßã ‡¶π‡¶ö‡ßç‡¶õ‡ßá",
        "domain": "‡¶°‡ßã‡¶Æ‡ßá‡¶á‡¶®",
        "prediction": "‡¶´‡¶≤‡¶æ‡¶´‡¶≤",
        "prob": "‡¶∏‡¶Æ‡ßç‡¶≠‡¶æ‡¶¨‡ßç‡¶Ø‡¶§‡¶æ",
        "conf": "‡¶Ü‡¶∏‡ßç‡¶•‡¶æ",
        "time": "‡¶∏‡¶Æ‡¶Ø‡¶º",
        "overall": "‡¶∏‡¶Æ‡¶ó‡ßç‡¶∞ ‡¶∏‡ßç‡¶•‡¶æ‡¶Ø‡¶º‡¶ø‡¶§‡ßç‡¶¨‡ßá‡¶∞ ‡¶Ü‡¶∏‡ßç‡¶•‡¶æ",
        "excellent": "üü¢ ‡¶ö‡¶Æ‡ßé‡¶ï‡¶æ‡¶∞",
        "moderate": "üü° ‡¶Æ‡¶æ‡¶ù‡¶æ‡¶Æ‡¶æ‡¶ù‡¶ø",
        "needs": "üî¥ ‡¶â‡¶®‡ßç‡¶®‡¶§‡¶ø ‡¶™‡ßç‡¶∞‡¶Ø‡¶º‡ßã‡¶ú‡¶®",
        "trend": "‡¶Ü‡¶∏‡ßç‡¶•‡¶æ ‡¶™‡ßç‡¶∞‡¶¨‡¶£‡¶§‡¶æ (‡¶∂‡ßá‡¶∑ 3)",
        "caption": "‡¶ï‡ßã‡¶Ø‡¶º‡¶æ‡¶®‡ßç‡¶ü‡¶æ‡¶Æ-‡¶™‡ßç‡¶∞‡¶æ‡¶£‡¶ø‡¶§, ‡¶Ö‡¶´‡¶≤‡¶æ‡¶á‡¶® ‡¶ü‡ßÅ‡¶≤ ‚Äî ‡¶∏‡ßç‡¶¨‡¶≤‡ßç‡¶™ ‡¶∏‡¶Æ‡ßç‡¶™‡¶¶ ‡¶∏‡ßá‡¶ü‡¶ø‡¶Ç‡¶∏‡ßá‡•§",
        "health_label_pos": "‡¶∏‡¶Æ‡ßç‡¶≠‡¶æ‡¶¨‡ßç‡¶Ø ‡¶Ö‡¶¨‡¶∏‡ßç‡¶•‡¶æ",
        "health_label_neg": "‡¶∏‡ßÅ‡¶∏‡ßç‡¶•",
        "soil_label_pos": "‡¶™‡ßÅ‡¶∑‡ßç‡¶ü‡¶ø ‡¶ò‡¶æ‡¶ü‡¶§‡¶ø",
        "soil_label_neg": "‡¶â‡¶∞‡ßç‡¶¨‡¶∞",
        "water_label_pos": "‡¶¶‡ßÇ‡¶∑‡¶ø‡¶§",
        "water_label_neg": "‡¶®‡¶ø‡¶∞‡¶æ‡¶™‡¶¶",
        "inputs": "‡¶á‡¶®‡¶™‡ßÅ‡¶ü",
        "noise_level": "‡¶®‡¶Ø‡¶º‡ßá‡¶ú ‡¶∏‡ßç‡¶§‡¶∞",
        "mode": "‡¶Æ‡ßã‡¶°",
        "note_panel": "YCS ‡¶ì ‡¶ï‡¶≤‡ßá‡¶ú ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶°‡¶Æ‡¶ø‡¶∂‡¶®‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø: explainable, robust, offline."
    },
    "‡§Æ‡§∞‡§æ‡§†‡•Ä": {  # Marathi
        "title": "NoiseShield AI ¬∑ ‡§ï‡•ç‡§µ‡§æ‡§Ç‡§ü‡§Æ-‡§™‡•ç‡§∞‡•á‡§∞‡§ø‡§§ ‡§®‡§ø‡§¶‡§æ‡§®",
        "sdg2": "SDG 2 ¬∑ ‡§â‡§™‡§æ‡§∏‡§Æ‡§æ‡§∞ ‡§®‡§ø‡§∞‡•ç‡§Æ‡•Ç‡§≤‡§®",
        "sdg3": "SDG 3 ¬∑ ‡§ö‡§æ‡§Ç‡§ó‡§≤‡•á ‡§Ü‡§∞‡•ã‡§ó‡•ç‡§Ø",
        "sdg6": "SDG 6 ¬∑ ‡§∏‡•ç‡§µ‡§ö‡•ç‡§õ ‡§™‡§æ‡§£‡•Ä",
        "tabs": ["‡§Æ‡§æ‡§§‡•Ä (SDG 2)", "‡§Ü‡§∞‡•ã‡§ó‡•ç‡§Ø (SDG 3)", "‡§™‡§æ‡§£‡•Ä (SDG 6)",
                 "‡§ï‡•ç‡§µ‡§æ‡§Ç‡§ü‡§Æ ‡§¶‡•É‡§∂‡•ç‡§Ø", "‡§Ö‡§π‡§µ‡§æ‡§≤", "SDG ‡§°‡•Ö‡§∂‡§¨‡•ã‡§∞‡•ç‡§°", "‡§ï‡•ç‡§∞‡•â‡§∏-‡§°‡•ã‡§Æ‡•á‡§® ‡§∏‡•ç‡§•‡•à‡§∞‡•ç‡§Ø"],
        "controls": "‡§Ö‚Äç‡•Ö‡§™ ‡§®‡§ø‡§Ø‡§Ç‡§§‡•ç‡§∞‡§£",
        "noise": "‡§∏‡•á‡§®‡•ç‡§∏‡§∞ ‡§®‡•â‡§à‡§ú (%)",
        "soil": "‡§Æ‡§æ‡§§‡•Ä ‡§∏‡•Å‡§™‡•Ä‡§ï‡§§‡§æ ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£ (‡§ë‡§´‡§≤‡§æ‡§á‡§®)",
        "health": "‡§Ü‡§∞‡•ã‡§ó‡•ç‡§Ø ‡§®‡§ø‡§¶‡§æ‡§® (‡§ë‡§´‡§≤‡§æ‡§á‡§®)",
        "water": "‡§™‡§æ‡§£‡•Ä ‡§ó‡•Å‡§£‡§µ‡§§‡•ç‡§§‡§æ (‡§ë‡§´‡§≤‡§æ‡§á‡§®)",
        "quantum": "‡§ï‡•ç‡§µ‡§æ‡§Ç‡§ü‡§Æ-‡§™‡•ç‡§∞‡•á‡§∞‡§ø‡§§ ‡§¶‡•É‡§∂‡•ç‡§Ø",
        "reports": "‡§∏‡•ç‡§•‡§æ‡§®‡§ø‡§ï ‡§Ö‡§π‡§µ‡§æ‡§≤ (‡§ë‡§´‡§≤‡§æ‡§á‡§®)",
        "dashboard": "SDG ‡§°‡•Ö‡§∂‡§¨‡•ã‡§∞‡•ç‡§° ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂",
        "stability": "‡§ï‡•ç‡§∞‡•â‡§∏-‡§°‡•ã‡§Æ‡•á‡§® ‡§∏‡•ç‡§•‡•à‡§∞‡•ç‡§Ø (Noise vs Probability)",
        "predicted": "‡§≠‡§æ‡§ï‡•Ä‡§§ ‡§™‡§∞‡§ø‡§£‡§æ‡§Æ",
        "confidence": "‡§µ‡§ø‡§∂‡•ç‡§µ‡§æ‡§∏",
        "baseline": "‡§¨‡•á‡§∏‡§≤‡§æ‡§á‡§® ‡§™‡•ç‡§∞‡•â‡§¨‡•Ö‡§¨‡§ø‡§≤‡§ø‡§ü‡•Ä",
        "var": "‡§Æ‡§§‡§≠‡•á‡§¶ variance",
        "download_soil": "‡§Æ‡§æ‡§§‡•Ä ‡§®‡§ø‡§ï‡§æ‡§≤ (CSV)",
        "download_health": "‡§Ü‡§∞‡•ã‡§ó‡•ç‡§Ø ‡§®‡§ø‡§ï‡§æ‡§≤ (CSV)",
        "download_water": "‡§™‡§æ‡§£‡•Ä ‡§®‡§ø‡§ï‡§æ‡§≤ (CSV)",
        "download_summary": "‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂ (CSV)",
        "download_pdf": "PDF ‡§Ö‡§π‡§µ‡§æ‡§≤",
        "pdf_missing": "'fpdf' ‡§á‡§®‡•ç‡§∏‡•ç‡§ü‡•â‡§≤ ‡§ï‡§∞‡§æ (pip install fpdf).",
        "why": "‡§π‡§æ ‡§™‡§∞‡§ø‡§£‡§æ‡§Æ ‡§ï‡§æ?",
        "last_safe": "‡§∂‡•á‡§µ‡§ü‡§ö‡•á ‡§∏‡•Å‡§∞‡§ï‡•ç‡§∑‡§ø‡§§ ‡§∞‡•Ä‡§°‡§ø‡§Ç‡§ó",
        "unstable": "‡§°‡•á‡§ü‡§æ ‡§Ö‡§∏‡•ç‡§•‡§ø‡§∞ ‚Äî ‡§∂‡•á‡§µ‡§ü‡§ö‡•á ‡§∏‡•Å‡§∞‡§ï‡•ç‡§∑‡§ø‡§§ ‡§∞‡•Ä‡§°‡§ø‡§Ç‡§ó ‡§¶‡§æ‡§ñ‡§µ‡§≤‡•á",
        "domain": "‡§°‡•ã‡§Æ‡•á‡§®",
        "prediction": "‡§®‡§ø‡§ï‡§æ‡§≤",
        "prob": "‡§™‡•ç‡§∞‡•â‡§¨‡•Ö‡§¨‡§ø‡§≤‡§ø‡§ü‡•Ä",
        "conf": "‡§µ‡§ø‡§∂‡•ç‡§µ‡§æ‡§∏",
        "time": "‡§µ‡•á‡§≥",
        "overall": "‡§è‡§ï‡•Ç‡§£ ‡§∏‡•ç‡§•‡•à‡§∞‡•ç‡§Ø ‡§µ‡§ø‡§∂‡•ç‡§µ‡§æ‡§∏",
        "excellent": "üü¢ ‡§â‡§§‡•ç‡§ï‡•É‡§∑‡•ç‡§ü",
        "moderate": "üü° ‡§Æ‡§ß‡•ç‡§Ø‡§Æ",
        "needs": "üî¥ ‡§∏‡•Å‡§ß‡§æ‡§∞‡§£‡§æ ‡§Ü‡§µ‡§∂‡•ç‡§Ø‡§ï",
        "trend": "‡§µ‡§ø‡§∂‡•ç‡§µ‡§æ‡§∏ ‡§ü‡•ç‡§∞‡•á‡§Ç‡§° (‡§∂‡•á‡§µ‡§ü‡§ö‡•á 3)",
        "caption": "‡§ï‡•ç‡§µ‡§æ‡§Ç‡§ü‡§Æ-‡§™‡•ç‡§∞‡•á‡§∞‡§ø‡§§, ‡§ë‡§´‡§≤‡§æ‡§á‡§® ‡§∏‡§æ‡§ß‡§® ‚Äî ‡§ï‡§Æ‡•Ä ‡§∏‡§Ç‡§∏‡§æ‡§ß‡§® ‡§≠‡§æ‡§ó‡§æ‡§Ç‡§∏‡§æ‡§†‡•Ä.",
        "health_label_pos": "‡§∏‡§Ç‡§≠‡§æ‡§µ‡•ç‡§Ø ‡§∏‡•ç‡§•‡§ø‡§§‡•Ä",
        "health_label_neg": "‡§®‡§ø‡§∞‡•ã‡§ó‡•Ä",
        "soil_label_pos": "‡§™‡•ã‡§∑‡§£ ‡§ï‡§Æ‡•Ä",
        "soil_label_neg": "‡§∏‡•Å‡§™‡•Ä‡§ï",
        "water_label_pos": "‡§¶‡•Ç‡§∑‡§ø‡§§",
        "water_label_neg": "‡§∏‡•Å‡§∞‡§ï‡•ç‡§∑‡§ø‡§§",
        "inputs": "‡§á‡§®‡§™‡•Å‡§ü‡•ç‡§∏",
        "noise_level": "‡§®‡•â‡§à‡§ú",
        "mode": "‡§Æ‡•ã‡§°",
        "note_panel": "YCS ‡§Ü‡§£‡§ø ‡§ï‡•â‡§≤‡•á‡§ú ‡§Ö‚Äç‡•Ö‡§°‡§Æ‡§ø‡§∂‡§®‡§∏‡§æ‡§†‡•Ä: explainable, robust, offline."
    },
}

ui_lang = st.sidebar.selectbox("Language", list(LANG.keys()), index=0)
L = LANG[ui_lang]

# =========================
# Banner
# =========================
st.markdown(f"""
<div style="text-align:center; margin-bottom:10px">
  <h2 style="font-weight:800; margin:0">{L['title']}</h2>
  <div class="sdg-badges">
    <div class="sdg-badge">{L['sdg2']}</div>
    <div class="sdg-badge">{L['sdg3']}</div>
    <div class="sdg-badge">{L['sdg6']}</div>
  </div>
</div>
""", unsafe_allow_html=True)

# =========================
# Helpers
# =========================
def seed_rng(seed=42): return np.random.default_rng(seed)

def inject_noise(X, pct, rng=None):
    if pct <= 0: return X.copy()
    if rng is None: rng = seed_rng(123)
    scale = pct / 100.0
    return X * (1.0 + rng.normal(0, scale, size=X.shape))

def make_submodels_from(base_lr, eps=0.03, n=3):
    scaler = base_lr.named_steps['standardscaler']
    lr = base_lr.named_steps['logisticregression']
    subs = []
    for k in range(n):
        lr_k = LogisticRegression()
        lr_k.classes_ = lr.classes_
        lr_k.coef_ = lr.coef_ * (1 + (k-1)*eps)         # -eps, 0, +eps
        lr_k.intercept_ = lr.intercept_ * (1 + (k-1)*eps)
        pipe_k = make_pipeline(StandardScaler(with_mean=scaler.with_mean, with_std=scaler.with_std))
        pipe_k.fit(np.zeros((1, scaler.scale_.shape[0])), [0])  # init scaler attrs
        pipe_k.named_steps['standardscaler'].mean_  = scaler.mean_.copy()
        pipe_k.named_steps['standardscaler'].scale_ = scaler.scale_.copy()
        pipe_k.steps.append(('logisticregression', lr_k))
        subs.append(pipe_k)
    return subs

def ensemble_predict_proba(submodels, X_row):
    probs = np.array([m.predict_proba(X_row)[0,1] for m in submodels])
    var = float(np.var(probs))
    if var > 0.02:
        w = np.ones_like(probs) / len(probs)       # destructive-like equalization
    else:
        centered = np.exp(-(probs - probs.mean())**2 / (2*0.0025))
        w = centered / centered.sum()              # constructive-like reinforcement
    return float(w @ probs), probs, w, var

def linear_contribs(pipe, x_row, feature_names):
    scaler = pipe.named_steps['standardscaler']
    lr = pipe.named_steps['logisticregression']
    x_std = (x_row - scaler.mean_) / scaler.scale_
    contrib = (lr.coef_.ravel() * x_std.ravel())
    order = np.argsort(-np.abs(contrib))
    return [(feature_names[i], float(contrib[i])) for i in order]

def robustness_curve(pipe_base, subs, x_row, noise_levels):
    base_p, ens_p = [], []
    for nl in noise_levels:
        xn = inject_noise(x_row, nl)
        base_p.append(pipe_base.predict_proba(xn)[0,1])
        ens, _, _, _ = ensemble_predict_proba(subs, xn)
        ens_p.append(ens)
    return np.array(base_p), np.array(ens_p)

def df_to_csv_bytes(df: pd.DataFrame) -> bytes:
    sio = StringIO()
    df.to_csv(sio, index=False)
    return sio.getvalue().encode()

def pdf_report_bytes(domain, inputs, label, conf, noise):
    if not HAS_FPDF: return None
    pdf = FPDF(); pdf.add_page()
    pdf.set_font("Arial", "B", 16); pdf.cell(0, 10, "NoiseShield Diagnostic Report", ln=1, align='C')
    pdf.set_font("Arial", "", 12)
    pdf.cell(0, 8, f"Date: {dt.datetime.now().strftime('%Y-%m-%d %H:%M')}", ln=1)
    pdf.cell(0, 8, f"{L['mode']}: {domain}", ln=1)
    pdf.multi_cell(0, 8, f"{L['inputs']}: {inputs}")
    pdf.cell(0, 8, f"{L['prediction']}: {label}", ln=1)
    pdf.cell(0, 8, f"{L['confidence']}: {conf}%", ln=1)
    pdf.cell(0, 8, f"{L['noise_level']}: {noise}%", ln=1)
    return pdf.output(dest='S').encode('latin-1')

# =========================
# Synthetic training (offline baseline)
# =========================
def synth_health_data(n=400, rng=None):
    if rng is None: rng = seed_rng(1)
    Hb = rng.normal(13, 2.2, n).clip(6, 20)
    WBC = rng.normal(7000, 2500, n).clip(2000, 30000)
    PLT = rng.normal(250000, 80000, n).clip(70000, 800000)
    Temp = rng.normal(36.8, 0.7, n).clip(34.5, 41.5)
    Pulse = rng.normal(80, 15, n).clip(45, 160)
    X = np.column_stack([Hb, WBC, PLT, Temp, Pulse])
    y = ((Hb < 11) | ((Temp > 37.8) & (WBC > 10000)) | (PLT < 120000)).astype(int)
    return X, y

def synth_water_data(n=400, rng=None):
    if rng is None: rng = seed_rng(2)
    pH = rng.normal(7.1, 0.6, n).clip(4.5, 9.5)
    turb = np.abs(rng.normal(5, 15, n)).clip(0, 200)
    tds = np.abs(rng.normal(300, 250, n)).clip(50, 2500)
    ec = np.abs(rng.normal(600, 400, n)).clip(50, 4500)
    temp = rng.normal(24, 6, n).clip(5, 45)
    X = np.column_stack([pH, turb, tds, ec, temp])
    y = ((turb > 10) | (tds > 1000) | (ec > 2000) | (pH < 6.0) | (pH > 8.5)).astype(int)
    return X, y

@st.cache_resource
def train_baselines():
    Xh, yh = synth_health_data()
    Xw, yw = synth_water_data()
    health_pipe = make_pipeline(StandardScaler(), LogisticRegression(max_iter=500))
    water_pipe  = make_pipeline(StandardScaler(), LogisticRegression(max_iter=500))
    health_pipe.fit(Xh, yh); water_pipe.fit(Xw, yw)
    return health_pipe, water_pipe

health_pipe, water_pipe = train_baselines()

# =========================
# Controls
# =========================
st.markdown(f"### {L['controls']}")
noise_pct = st.sidebar.slider(L["noise"], 0, 100, 0, step=5)

tabs = st.tabs(L["tabs"])

# =========================
# SOIL TAB
# =========================
with tabs[0]:
    st.subheader(L["soil"])
    c1, c2 = st.columns(2)
    with c1:
        spH  = st.number_input("Soil pH", 3.0, 10.0, 6.5)
        N    = st.number_input("Nitrogen (mg/kg)", 0.0, 200.0, 40.0)
        P    = st.number_input("Phosphorus (mg/kg)", 0.0, 200.0, 30.0)
    with c2:
        K    = st.number_input("Potassium (mg/kg)", 0.0, 300.0, 120.0)
        moist= st.number_input("Soil Moisture (%)", 0.0, 100.0, 25.0)
    X0s = np.array([[spH, N, P, K, moist]])
    Xns = inject_noise(X0s, noise_pct)

    @st.cache_resource
    def train_soil_baseline():
        rng = seed_rng(3); n = 400
        pH = rng.normal(6.5, 0.8, n).clip(3.5, 9.5)
        N  = rng.normal(50, 25, n).clip(0, 200)
        P  = rng.normal(40, 20, n).clip(0, 200)
        K  = rng.normal(150, 60, n).clip(0, 300)
        M  = rng.normal(30, 15, n).clip(0, 100)
        X  = np.column_stack([pH, N, P, K, M])
        y  = ((N < 30) | (P < 20) | (K < 80) | (pH < 5.5) | (pH > 8.5)).astype(int)
        pipe = make_pipeline(StandardScaler(), LogisticRegression(max_iter=500))
        pipe.fit(X, y); return pipe

    soil_pipe = train_soil_baseline()

    if st.button("Run Soil Analysis"):
        p_lr = soil_pipe.predict_proba(Xns)[0,1]
        subs_s = make_submodels_from(soil_pipe, eps=0.04)
        p_ens, sub_probs, weights, var = ensemble_predict_proba(subs_s, Xns)
        y_pred = int(p_ens >= 0.5)
        label  = L["soil_label_pos"] if y_pred==1 else L["soil_label_neg"]
        conf   = round(p_ens * 100, 2)

        st.markdown(f"**{L['predicted']}:** {label}")
        st.progress(int(conf))
        st.write(f"{L['confidence']}: **{conf}%** ¬∑ {L['baseline']}: {p_lr:.2f} ¬∑ {L['var']}: {var:.4f}")

        # Confidence-aware message
        if conf >= 80: st.success(f"üü¢ {L['confidence']}: {conf}%")
        elif conf >= 50: st.warning(f"üü° {L['confidence']}: {conf}%")
        else: st.error(f"üî¥ {L['confidence']}: {conf}%")

        # Interference visualization
        with st.expander("Interference Visualization"):
            fig, ax = plt.subplots()
            ax.bar([f"Sub{i+1}" for i in range(len(sub_probs))], sub_probs, alpha=0.8)
            ax.axhline(p_ens, color='r', linestyle='--', label='Final (Interference)')
            ax.set_ylim(0,1); ax.set_ylabel("Probability"); ax.legend()
            st.pyplot(fig)

        # Explainability
        with st.expander(f"üß† {L['why']}"):
            expl = linear_contribs(soil_pipe, Xns, ["pH","Nitrogen","Phosphorus","Potassium","Moisture"])
            df_expl = pd.DataFrame(expl, columns=["Feature","Contribution"]).set_index("Feature")
            st.bar_chart(df_expl)

        # Last-known-safe memory
        if conf >= 50:
            st.session_state["last_stable"]["Soil"] = {
                "inputs": X0s.tolist(), "label": label, "confidence": conf, "time": dt.datetime.now().isoformat()
            }
        else:
            last = st.session_state["last_stable"].get("Soil")
            if last:
                st.info(f"‚ö†Ô∏è {L['unstable']}: {last['time']}")
                st.json(last)

        # Persist results (dashboard + reports)
        st.session_state["results"]["Soil"] = {
            "confidence": float(conf), "prob": float(p_ens), "label": label,
            "time": dt.datetime.now().isoformat()
        }
        hist = st.session_state["history"]["Soil"]; hist.append(conf); st.session_state["history"]["Soil"] = hist[-3:]

        # Per-run CSV
        row = {
            L["domain"]: "Soil", "pH": float(spH), "Nitrogen": float(N), "Phosphorus": float(P),
            "Potassium": float(K), "Moisture": float(moist), L["prediction"]: label,
            L["prob"]: float(p_ens), L["conf"]: float(conf), L["time"]: dt.datetime.now().isoformat()
        }
        st.download_button(L["download_soil"], df_to_csv_bytes(pd.DataFrame([row])),
                           file_name="noiseshield_soil_result.csv", mime="text/csv")

        # Optional PDF
        if HAS_FPDF:
            pdf_bytes = pdf_report_bytes("Soil", row, label, conf, noise_pct)
            st.download_button(f"üìÑ {L['download_pdf']}", pdf_bytes, "noiseshield_soil_report.pdf",
                               mime="application/pdf")
        else:
            st.caption(L["pdf_missing"])

# =========================
# HEALTH TAB
# =========================
with tabs[1]:
    st.subheader(L["health"])
    c1, c2 = st.columns(2)
    with c1:
        hb    = st.number_input("Hemoglobin (g/dL)", 0.0, 25.0, 12.5)
        wbc   = st.number_input("WBC (cells/¬µL)", 0.0, 30000.0, 7000.0)
        pltlt = st.number_input("Platelets (cells/¬µL)", 0.0, 900000.0, 250000.0)
    with c2:
        temp  = st.number_input("Body Temp (¬∞C)", 30.0, 45.0, 36.8)
        pulse = st.number_input("Pulse Rate (bpm)", 30.0, 200.0, 80.0)
    X0 = np.array([[hb, wbc, pltlt, temp, pulse]])
    Xn = inject_noise(X0, noise_pct)

    if st.button("Run Health Analysis"):
        p_lr = health_pipe.predict_proba(Xn)[0,1]
        subs_h = make_submodels_from(health_pipe, eps=0.04)
        p_ens, sub_probs, weights, var = ensemble_predict_proba(subs_h, Xn)
        y_pred = int(p_ens >= 0.5)
        label  = L["health_label_pos"] if y_pred==1 else L["health_label_neg"]
        conf   = round(p_ens * 100, 2)

        st.markdown(f"**{L['predicted']}:** {label}")
        st.progress(int(conf))
        st.write(f"{L['confidence']}: **{conf}%** ¬∑ {L['baseline']}: {p_lr:.2f} ¬∑ {L['var']}: {var:.4f}")

        if conf >= 80: st.success(f"üü¢ {L['confidence']}: {conf}%")
        elif conf >= 50: st.warning(f"üü° {L['confidence']}: {conf}%")
        else: st.error(f"üî¥ {L['confidence']}: {conf}%")

        with st.expander("Interference Visualization"):
            fig, ax = plt.subplots()
            ax.bar([f"Sub{i+1}" for i in range(len(sub_probs))], sub_probs, alpha=0.8)
            ax.axhline(p_ens, color='r', linestyle='--', label='Final (Interference)')
            ax.set_ylim(0,1); ax.set_ylabel("Probability"); ax.legend()
            st.pyplot(fig)

        with st.expander(f"üß† {L['why']}"):
            expl = linear_contribs(health_pipe, Xn, ["Hemoglobin","WBC","Platelets","Temp","Pulse"])
            df_expl = pd.DataFrame(expl, columns=["Feature","Contribution"]).set_index("Feature")
            st.bar_chart(df_expl)

        if conf >= 50:
            st.session_state["last_stable"]["Health"] = {
                "inputs": X0.tolist(), "label": label, "confidence": conf, "time": dt.datetime.now().isoformat()
            }
        else:
            last = st.session_state["last_stable"].get("Health")
            if last:
                st.info(f"‚ö†Ô∏è {L['unstable']}: {last['time']}")
                st.json(last)

        st.session_state["results"]["Health"] = {
            "confidence": float(conf), "prob": float(p_ens), "label": label,
            "time": dt.datetime.now().isoformat()
        }
        hist = st.session_state["history"]["Health"]; hist.append(conf); st.session_state["history"]["Health"] = hist[-3:]

        row = {
            L["domain"]: "Health", "Hemoglobin": float(hb), "WBC": float(wbc), "Platelets": float(pltlt),
            "Temp": float(temp), "Pulse": float(pulse), L["prediction"]: label, L["prob"]: float(p_ens),
            L["conf"]: float(conf), L["time"]: dt.datetime.now().isoformat()
        }
        st.download_button(L["download_health"], df_to_csv_bytes(pd.DataFrame([row])),
                           file_name="noiseshield_health_result.csv", mime="text/csv")
        if HAS_FPDF:
            pdf_bytes = pdf_report_bytes("Health", row, label, conf, noise_pct)
            st.download_button(f"üìÑ {L['download_pdf']}", pdf_bytes, "noiseshield_health_report.pdf",
                               mime="application/pdf")
        else:
            st.caption(L["pdf_missing"])

# =========================
# WATER TAB
# =========================
with tabs[2]:
    st.subheader(L["water"])
    c1, c2 = st.columns(2)
    with c1:
        ph   = st.number_input("pH", 0.0, 14.0, 7.2)
        turb = st.number_input("Turbidity (NTU)", 0.0, 500.0, 5.0)
        tds  = st.number_input("TDS (ppm)", 0.0, 5000.0, 300.0)
    with c2:
        ec   = st.number_input("EC (¬µS/cm)", 0.0, 10000.0, 600.0)
        wtemp= st.number_input("Water Temp (¬∞C)", 0.0, 60.0, 25.0)
    X0w = np.array([[ph, turb, tds, ec, wtemp]])
    Xnw = inject_noise(X0w, noise_pct)

    if st.button("Run Water Analysis"):
        p_lr = water_pipe.predict_proba(Xnw)[0,1]
        subs_w = make_submodels_from(water_pipe, eps=0.04)
        p_ens, sub_probs, weights, var = ensemble_predict_proba(subs_w, Xnw)
        y_pred = int(p_ens >= 0.5)
        label  = L["water_label_pos"] if y_pred==1 else L["water_label_neg"]
        conf   = round(p_ens * 100, 2)

        st.markdown(f"**{L['predicted']}:** {label}")
        st.progress(int(conf))
        st.write(f"{L['confidence']}: **{conf}%** ¬∑ {L['baseline']}: {p_lr:.2f} ¬∑ {L['var']}: {var:.4f}")

        if conf >= 80: st.success(f"üü¢ {L['confidence']}: {conf}%")
        elif conf >= 50: st.warning(f"üü° {L['confidence']}: {conf}%")
        else: st.error(f"üî¥ {L['confidence']}: {conf}%")

        with st.expander("Interference Visualization"):
            fig, ax = plt.subplots()
            ax.bar([f"Sub{i+1}" for i in range(len(sub_probs))], sub_probs, alpha=0.8)
            ax.axhline(p_ens, color='r', linestyle='--', label='Final (Interference)')
            ax.set_ylim(0,1); ax.set_ylabel("Probability"); ax.legend()
            st.pyplot(fig)

        with st.expander(f"üß† {L['why']}"):
            expl = linear_contribs(water_pipe, Xnw, ["pH","Turbidity","TDS","EC","Water Temp"])
            df_expl = pd.DataFrame(expl, columns=["Feature","Contribution"]).set_index("Feature")
            st.bar_chart(df_expl)

        if conf >= 50:
            st.session_state["last_stable"]["Water"] = {
                "inputs": X0w.tolist(), "label": label, "confidence": conf, "time": dt.datetime.now().isoformat()
            }
        else:
            last = st.session_state["last_stable"].get("Water")
            if last:
                st.info(f"‚ö†Ô∏è {L['unstable']}: {last['time']}")
                st.json(last)

        st.session_state["results"]["Water"] = {
            "confidence": float(conf), "prob": float(p_ens), "label": label,
            "time": dt.datetime.now().isoformat()
        }
        hist = st.session_state["history"]["Water"]; hist.append(conf); st.session_state["history"]["Water"] = hist[-3:]

        row = {
            L["domain"]: "Water", "pH": float(ph), "Turbidity": float(turb), "TDS": float(tds),
            "EC": float(ec), "WaterTemp": float(wtemp), L["prediction"]: label, L["prob"]: float(p_ens),
            L["conf"]: float(conf), L["time"]: dt.datetime.now().isoformat()
        }
        st.download_button(L["download_water"], df_to_csv_bytes(pd.DataFrame([row])),
                           file_name="noiseshield_water_result.csv", mime="text/csv")
        if HAS_FPDF:
            pdf_bytes = pdf_report_bytes("Water", row, label, conf, noise_pct)
            st.download_button(f"üìÑ {L['download_pdf']}", pdf_bytes, "noiseshield_water_report.pdf",
                               mime="application/pdf")
        else:
            st.caption(L["pdf_missing"])

# =========================
# QUANTUM VIEW
# =========================
with tabs[3]:
    st.subheader(L["quantum"])
    st.write("‚Ä¢ Multiple perturbed submodels (logistic regressions) act like **amplitude paths**.")
    st.write("‚Ä¢ When they disagree strongly, weights equalize ‚Üí **noise cancellation** (destructive-like).")
    st.write("‚Ä¢ When they agree, central estimate is reinforced ‚Üí **stability** (constructive-like).")
    st.markdown(f"<div class='panel'>{L['note_panel']}</div>", unsafe_allow_html=True)

# =========================
# REPORTS (summary)
# =========================
with tabs[4]:
    st.subheader(L["reports"])
    res = st.session_state["results"]
    rows = []
    for dom in ["Soil","Health","Water"]:
        r = res.get(dom)
        if r is not None:
            rows.append({L["domain"]: dom, L["prediction"]: r["label"],
                         L["prob"]: r["prob"], L["conf"]: r["confidence"], L["time"]: r["time"]})
        else:
            rows.append({L["domain"]: dom, L["prediction"]: "‚Äî",
                         L["prob"]: "‚Äî", L["conf"]: 0, L["time"]: "‚Äî"})
    df_all = pd.DataFrame(rows)
    st.dataframe(df_all, use_container_width=True)
    st.download_button(f"‚¨áÔ∏è {L['download_summary']}",
                       data=df_to_csv_bytes(df_all),
                       file_name="noiseshield_summary.csv", mime="text/csv")

# =========================
# DASHBOARD
# =========================
with tabs[5]:
    st.subheader(L["dashboard"])
    r = st.session_state["results"]
    soil_conf   = float((r["Soil"]   or {}).get("confidence", 0.0))
    health_conf = float((r["Health"] or {}).get("confidence", 0.0))
    water_conf  = float((r["Water"]  or {}).get("confidence", 0.0))

    c1, c2, c3 = st.columns(3)
    c1.metric(L["sdg2"], f"{soil_conf:.1f}%")
    c2.metric(L["sdg3"], f"{health_conf:.1f}%")
    c3.metric(L["sdg6"], f"{water_conf:.1f}%")

    overall = round((soil_conf + health_conf + water_conf) / 3, 1)
    status = L["excellent"] if overall >= 80 else (L["moderate"] if overall >= 50 else L["needs"])
    st.markdown(f"### {L['overall']}: **{overall}%** ¬∑ {status}")

    with st.expander(L["trend"]):
        fig, ax = plt.subplots()
        ax.plot(st.session_state["history"]["Soil"],   "o-", label="Soil")
        ax.plot(st.session_state["history"]["Health"], "o-", label="Health")
        ax.plot(st.session_state["history"]["Water"],  "o-", label="Water")
        ax.set_ylim(0, 100); ax.set_ylabel("Confidence (%)"); ax.set_xlabel("Recent Tests")
        ax.legend(); st.pyplot(fig)

    st.caption(L["caption"])

# =========================
# CROSS-DOMAIN STABILITY (Soil, Health, Water)
# =========================
with tabs[6]:
    st.subheader(L["stability"])
    st.caption("Noise (%) ‚Üí Probability (baseline vs interference)")

    levels = [0, 20, 40, 60, 80, 100]

    # Soil probe point (use current inputs)
    soil_subs = make_submodels_from(train_soil_baseline(), eps=0.04)
    soil_base, soil_ens = robustness_curve(train_soil_baseline(), soil_subs, np.array([[6.5,40,30,120,25]]), levels)

    # Health probe (typical normal vitals)
    health_subs = make_submodels_from(health_pipe, eps=0.04)
    health_base, health_ens = robustness_curve(health_pipe, health_subs, np.array([[12.5,7000,250000,36.8,80]]), levels)

    # Water probe (typical potable water)
    water_subs = make_submodels_from(water_pipe, eps=0.04)
    water_base, water_ens = robustness_curve(water_pipe, water_subs, np.array([[7.2,5,300,600,25]]), levels)

    def plot_curve(title, base, ens):
        st.markdown(f"**{title}**")
        fig, ax = plt.subplots()
        ax.plot(levels, base, marker="o", label="Baseline (LR)")
        ax.plot(levels, ens, marker="o", label="Interference Ensemble")
        ax.set_xlabel("Noise (%)"); ax.set_ylabel("Positive Probability"); ax.set_ylim(0,1); ax.legend()
        st.pyplot(fig)

    plot_curve("Soil",   soil_base, soil_ens)
    plot_curve("Health", health_base, health_ens)
    plot_curve("Water",  water_base, water_ens)
